---
layout: post
title: blah~
tags: 
- "杂碎"
status: publish
type: post
published: true
meta: 
  _edit_last: "2"
---

“好久没更新了”~orz又这么开头了。

昨天下午给新人讲东西时候差点着起急来，耐心什么的实在是差了些。同理，这个blog也快不会写了。笔记什么的都有记在在本子上，怨念什么的也都在twi上发泄了个精光。想翻译点东西可是怎么都觉得驴唇不对马嘴，就全部作罢。

完整的橇课，上午看书下午敲代码。再同各种善意的小朋友交流下，要说充实倒确实非比寻常。不过总觉得倦的厉害，简单一个“中午不睡下午崩溃”似乎还说不过去。代码就够傲骄了，人自然更难伺候。写这句话的时候当年推销饮水机的两位童鞋又敲门进来推销凉席，都不容易。

还是说代码吧。敏捷编程什么都领悟不了还扯淡什么人生。一天几十行，我起草一份《蜗牛宣言》好了~ 

想用rails换掉学校网站正在用的这个aspx系统。都说rails不好维护，可是当前的这aspx系统我已经完全维护无力了，瞅着bug在那里只能对着那两万行的一个类发呆。用rails重写最起码我能维护，能用不能用写出来再说。（敏捷什么的就当笑话听吧）

闲着把寒假时候烂掉的那个堆栈机完善了下，随后发懒两个星期没碰代码，回头想下应该差不多能用了（当然是想当然）。代码改的相当蛋疼，用上了ruby那VALUE式的tagged pointer，没打算oo的也在c里把类型搞成了对象，再就是大量少于十行的小函数。以前只是听说lua的upvalue实现很简洁，看了下发现用在这里不合适，lua的临时变量和求值栈都在同一个栈帧里连续着，只要不是闭包的变量在函数执行完立即回收。而这个堆栈机里的堆栈只是求值栈，临时变量都在一个动态分配的结构体里。这里让栈帧在函数执行完后统统保留，等着GC回收就是。

从淘宝上打印了本《莱昂氏unix源码剖析》，作者好个惜字如金，读起来也很吃力。 前半部分是unix v6的全部源码，仅9000行出头。随便翻下就被雷了，内存管理的malloc和mfree不到百行，而枚举一个进程的子进程什么的就都这样:

<pre lang="c">
for(p = &proc[0]; p < &proc[NPROC]; p++)
if (a->p_pid == p->p_ppid) {
        p->p_ppid = 1;
        if (p->p_stat == SSTOP)
                setrun(p);
}
swtch();
</pre>

简单粗暴，多好。
