
- 主题：透明的分布式对象的开发方法注定失败
- 透明的分布式对象这个 vision 暗示开发者用起常规的 OO 开发方法，但实际上并不适用于分布式环境
- 这个开发方法一般分成三步：1. 先不关心对象的位置，也不关心通信，在本地统一地开发；2. 调整对象的位置，和通信方式；3. 在分布环境中实测；
- 这个开发方法认为，正确的 “故障点” 、或者机器边界会随着开发过程自动显现；而对象在本地还是在远程，对计算的正确性本身没有影响；只要一个对象支持一个固定的接口，而接口实现的语义一样，那么对象的位置将不再重要；
- 这样设计出的系统有多种优势：应用维护起来更加灵活，可以拿对象为单位上线，对整个系统没有影响，可以轻易地移动对象的位置；
- 这个 vision 的理由大体有：1. 完整的应用使用一致的 OO 夹沟；2. 故障和性能因素与实现相关，但在初始的设计阶段可以不管它们；3. 对象的接口与调用的上下文无关；
- 可惜这三个理由没一个成立；
Deja Vu All Over Again
- 统一对象模型的理念曾出现过很多次，抹平本地计算和远程计算差异的尝试也一直都存在；
- 通信协议的设计一般存在两条路线：1. 将通信集成在现有的语言模型中；2. 应对分布式环境中的特有问题；
- 每十年，会有人发现分布式应用程序占的比例较少，他们认为原因在于语言的模型不能适应分布式环境，然后他们会设计一个编程模型声称自己的模型更契合分布式环境，十年后又是一轮；
- 分布式环境中最困难的并不是接口设计，而是应对 partial failure、缺少中心的资源管理；
Local and Distributed Computing
- 差异主要体现在：延时、内存地址空间、partial failure 和 concurrency
- 其中延时最显眼但最不显著；
- Memory Access：非统一地址空间；听信 "remote access and local access are exactly same" 神话的开发者相信他们不需要改变自己思考编程的方式；
- Partial Failure 是分布式计算的核心问题；在发生 Partial Failure 之后，双方都不能明确知道当前的状态；
- 稳定性不是正确地实现组件的接口就足够，还要关心组件之间的调用方式；
The Myth of "QoS"
- 靠超时与重试不能解决问题
Lessons from NFS
- soft mount 将网络故障暴露给客户端，NFS 的早期，管理员试图通过调参数来应对 QoS 问题（超时时间、重试次数），类似的尝试失败了；
- hard mount 则意味着在服务器重启之前阻塞所有客户端；避免了 partial failure 但是导致级联故障，挂一台挂一片；没有调优 QoS 的可能；
- NFS 是个 C/S 的无状态协议，着意味着故障来源可以限制在客户端、服务端、网络三者之一；其组合要远少于 p2p 分布式对象架构；
- NFS 可能是最成功的分布式系统了（1994），但是对 NFS 而言，可靠性（Robutness）的提升也意味着可扩展性的降低；
Taking the Difference Seriously
- 将两个模型合并，需要语言的支持，二者的交集使得本地开发更加困难；
- 开发者在开发期间必须明确发送消息的对象是本地还是远程，并作不同的设计考量；
- 将差异保持可见，开发者不会忘记两者的差异而犯错误；
- 承认、接受两者的差异不可忽略，可以将社区、学术界之间的精力放在更务实的主题上；
