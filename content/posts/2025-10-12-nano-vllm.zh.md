
最近想学习一下工业级的推理引擎的设计，不过 vLLM 和 SGLang 似乎都已经发展的比较复杂了。前段时间看到一个[nano-vllm](https://github.com/GeeeekExplorer/nano-vllm)，它的代码比较简短，但是也有一个完整的 page attention 和 scheduler 的实现，国庆假期学习了一下，很有意思，在这里记录一下。

感兴趣的点主要在：

- 怎样处理多个 request 的？
- 怎样抢占的？
- 怎样管理 kv cache 的内存的？

## 代码结构

nano-vllm 的代码结构非常简洁，除了一个内置的 qwen3 模型的结构定义，主要代码在 engine/ 目录中，只有这几个文件：

- `llm_engine.py`：提供 generate 接口，把请求交给 scheduler 处理；
- `sequence.py`：请求被包成 Sequence，管理每个请求的生命周期和内存映射关系；
- `scheduler.py`：管理请求队列，管理调度和处理抢占；
- `block_manager.py`：管理 KV Cache 内存块的分配和释放，以及按 hash 进行复用；
- `model_runner.py`：执行模型前向推理，scheduler 每一次调度，均对应一次执行；

## 基本概念

### Page Attention

vLLM 之所以能快速流行，关键在于其 Page Attention 技术。nano-vllm 的核心设计也基于 Page Attention，可以看作是 vLLM 的精简实现。

在推理过程中，对内存管理的需求很直接：

1. 显卡的 KV Cache 总空间是固定的，除了模型权重等固定占用外，剩余显存都应当留给 KV Cache。怎样分配和管理这部分内存？
2. 用户请求的长度长短不同，每个请求对应的 KV Cache 也长短差异极大，如何在同一个 batch 内支持这些不同长度的请求？

Page Attention 的思路也很直接，就是借鉴操作系统的 Page Cache，将所有 KV Cache 内存细分为 Block 并管理映射，这样可以：

1. 全局管理 KV Cache 相关的内存，通过分配表来管理 KV Cache Block 的分配与释放；
2. 允许为不同的请求关联不同的 Block，从而支持不同长度的请求，乃至允许复用前缀，减少重复计算；

### Sequence 和 Block

在 nano-vllm 的 Page Attention 实现中，主要是 `Sequence` 和 `Block` 两个概念。

在 nano-vllm 中，每个用户请求都会被封装成一个 `Sequence` 对象。Sequence 对象的字段如下：

```python
class Sequence:
    def __init__(self, token_ids: list[int], sampling_params = SamplingParams()):
        self.seq_id = next(Sequence.counter)
        self.status = SequenceStatus.WAITING  # RUNNING, FINISHED
        self.token_ids = copy(token_ids)
        self.last_token = token_ids[-1]
        self.num_tokens = len(self.token_ids)
        self.num_prompt_tokens = len(token_ids)
        self.num_cached_tokens = 0
        self.block_table = []
        self.temperature = sampling_params.temperature
        self.max_tokens = sampling_params.max_tokens
        self.ignore_eos = sampling_params.ignore_eos
```

每个 `Sequence` 作为用户的请求的表示，它的 status 字段也会和调度生命周期有关。

除了状态字段，主要的字段就是 `block_table`，其他的字段可以认为都是辅助信息。`block_table` 是一个列表，列表中每个元素是一个整数，表示 Sequence 中的 KV Cache 对应的 Block 的 ID。

在 nano-vllm 中，每个 Block 的大小是等于 256 个 embedding，如果一个用户请求中有 1024 个 token，那么就是 4 个 Block。

Block 的结构更简单：

```python
class Block:
    def __init__(self, block_id):
        self.block_id = block_id
        self.ref_count = 0
        self.hash = -1
        self.token_ids = []
```

每个 Block 有一个唯一的 ID，一个引用计数，一个 hash，以及一个 token_ids 列表。

唯一的 ID 用于 Block 物理页的映射，每一块物理 Block 的内存，对应一个这个 ID。这个 ID 也是 `Sequence` 中 `block_table` 中，从序列的下标到 Block 映射关系中使用的 ID。

`hash` 会用于前缀缓存复用，稍后会回到这里。

### 调度周期

## 主要流程

### 请求调度

### Block 分配