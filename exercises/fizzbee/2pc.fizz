---
# Disable  deadlock detection for now. We will address it later.
deadlock_detection: false
---

role Coordinator:
    action Init:
        self.status = "init"

    action Commit:
        require(self.status == "init")
        self.status = "working"

        for p in participants:
            vote = p.Prepare()
            if vote == "aborted":
                self.Finalize("aborted")
                return
        
        self.Finalize("committed")

    func Finalize(decision): 
        require(self.status in ["working", decision])
        self.status = decision
        for p in participants:
            p.Finalize(decision)

    fair action Timeout:
        if self.status == "committed":
            self.Finalize("committed")
        else:
            self.Finalize("aborted")


role Participant:
    action Init:
        self.status = "init"

    func Prepare():
        vote = any ["prepared", "aborted"]
        self.status = vote
        return vote

    func Finalize(decision):
        self.status = decision


NUM_PARTICIPANTS = 2

action Init:
    coordinator = Coordinator()
    participants = []
    for i in range(NUM_PARTICIPANTS):
        participants.append(Participant())


always assertion ParticipantsConsistent:
    for p1 in participants:
        for p2 in participants:
            if p1.status == "committed" and p2.status == "aborted":
                return False
    return True


exists assertion AllParticipantsCommitted:
    for p1 in participants:
            if p1.status != 'committed':
                return False
    return True


eventually always assertion CoordinatorTerminated:
    return coordinator.status != 'working'


eventually always assertion AllParticipantsTerminated:
    for p1 in participants:
        if p1.status == 'prepared':
            return False
    return True
