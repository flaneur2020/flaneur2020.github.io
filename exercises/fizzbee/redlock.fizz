NUM_PROCESS = 2
EXPIRATION = 10


action Init:
    processes = []
    for i in range(NUM_PROCESS):
        processes.append(Process())
    lock = record(owner=None, expration_time=-1)
    clock = 0
    next_fence_token = 1
    last_seen_fence_token = 0


action TickClock:
    clock += 1


role Process:
    action Init:
        self.in_mutex = False

    action Next:
        # before critical section
        pass

        atomic:
            require lock.owner == None or clock >= lock.expration_time
            lock = record(owner=self.__id__, expration_time=clock+EXPIRATION)
            self.fence_token = next_fence_token
            next_fence_token += 1

        # can only enter the mutex if we have the biggest token
        atomic:
            if self.fenc_token > last_seen_fence_token:
                last_seen_fence_token = self.fence_token
                self.in_mutex = True
                pass

        self.in_mutex = False

        # release the lock. this lock is possible to be acquired by another
        # process because it's expiration_time exceeded.
        atomic:
            if lock.owner == self.__id__:
                lock.owner = None


always assertion MutalExclusion:
    return not any([
        p1.in_mutex and p2.in_mutex
        for p1 in processes
        for p2 in processes
        if p1 != p2
    ])
